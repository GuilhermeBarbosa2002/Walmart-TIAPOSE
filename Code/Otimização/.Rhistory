start           = 12 * bits_workers + 1,
elements        = 16,
dimension_start = 13,
bits            = bits_orders), nrow = 4, ncol = 4)
product_orders
monthly_effort <- total_number_of_workers(hired_workers) + total_number_of_orders(product_orders)
monthly_effort
sales          <- calculate_sales(actual_sales, hired_workers, product_orders)
monthly_profit <- sales_in_usd(sales) - total_costs(hired_workers, product_orders, sales)
monthly_profit
sales
bs <- rga$population[rga$evaluations == min(rga$evaluations), ]
hired_workers  <- matrix(matrix_transform(solution        = bs,
start           = 1,
elements        = 12,
dimension_start = 1,
bits            = bits_workers), nrow = 3, ncol = 4)
product_orders <- matrix(matrix_transform(solution        = bs,
start           = 12 * bits_workers + 1,
elements        = 16,
dimension_start = 13,
bits            = bits_orders), nrow = 4, ncol = 4)
monthly_effort <- total_number_of_workers(hired_workers) + total_number_of_orders(product_orders)
sales          <- calculate_sales(actual_sales, hired_workers, product_orders)
monthly_profit <- sales_in_usd(sales) - total_costs(hired_workers, product_orders, sales)
monthly_profit
bs
hired_workers
product_orders
bs
hired_workers
hired_workers
product_orders
sales
xlim = c(100000, 0) # x-axis limits
ylim = c(100000, 0) # y-axis limits
COL=paste("gray",80-ITER*4,sep="") # set the points color depending on ITER
ITER           <- 1
COL=paste("gray",80-ITER*4,sep="") # set the points color depending on ITER
COL
?rbga.bin
source("C:/Users/Neon/Desktop/rbga-binScript.R")
source("C:/Users/Neon/Desktop/rbga-binScript.R")
source("C:/Users/Neon/Desktop/rbga-binScript.R")
source("C:/Users/Neon/Desktop/rbga-binScript.R")
source("C:/Users/Neon/Desktop/rbga-binScript.R")
# Identificar os departamentos
departments <- rep(1:4, each = 4)
departments
# Definir os níveis de vendas para cada tipo de funcionário
sales_levels <- c(4000, 7000, 9500) * 4
# Identificar os departamentos
departments <- rep(1:4, each = 4)
# Inicializar o vetor uppers
uppers <- rep(0, 28)
uppers
# Calcular os valores uppers para os primeiros 12 elementos
actual_sales_by_dep <- colSums(actual_sales)
actual_sales_by_dep
sales_levels
i = 1
j = 1
index <- (i - 1) * 4 + j
index
sales_levels[i]
actual_sales_by_dep[j]
calculate_number_max_func(sales_levels[i], actual_sales_by_dep[j])
sales_levels[i]
actual_sales <- data.frame(
WSdep1 = c(54480 , 42221 , 36267 , 35283 ),
WSdep2 = c(159460, 156945, 146388, 132156),
WSdep3 = c(63584 , 62888 , 62768 , 60279 ),
WSdep4 = c(127009, 124560, 123346, 117375)
)
# global variables (can be used inside the functions):
D            <- 28 # dimension
Low          <- rep(0, 28) # Lower
Up           <- calculate_uppers(actual_sales) # Upper
bits_workers <- ceiling(max(log(Up[1:12] , 2))) # Bits for Hired Workers
bits_orders  <- ceiling(max(log(Up[13:28], 2))) # Bits for Product Orders
N            <- 100 # number of iterations
size         <- 12 * bits_workers + 16 * bits_orders # solution size
cat("Tabu Search Sphere D =", D,"( iters =", N,")\n")
# Building Initial configuration
s <- c()
# Building Initial configuration for Hired Workers
s <- initial_config_build(config     = s,
n_bits     = bits_workers,
dimensions = 12)
# Building Initial configuration for Product Orders
s <- initial_config_build(config     = s,
n_bits     = bits_orders,
dimensions = 16)
s
cat("Tabu Search Sphere D =", D,"( iters =", N,")\n")
# Building Initial configuration
s <- c()
# if needed, install this package:
# install.packages("tabuSearch")
library(tabuSearch)
library(adana)
source("C:/Users/Neon/Documents/Universidade/4º Ano/TIAPOSE/Walmart-TIAPOSE/Code/OTIMIZATION/Functions_Otimization.R")
# Function to divide binary array by bits
matrix_transform <- function(solution, start, elements, dimension_start, bits){
matrix_final <- c()
for(i in 1:elements){
matrix_final[i]  <- bin2int(solution[start:(start + bits - 1)])
start <- start + bits
}
return(matrix_final)
}
# Evaluation Function
eval <- function(solution){
hired_workers  <- matrix(matrix_transform(solution        = solution,
start           = 1,
elements        = 12,
dimension_start = 1,
bits            = bits_workers), nrow = 3, ncol = 4)
product_orders <- matrix(matrix_transform(solution        = solution,
start           = 12 * bits_workers + 1,
elements        = 16,
dimension_start = 13,
bits            = bits_orders), nrow = 4, ncol = 4)
sales          <- calculate_sales(actual_sales, hired_workers, product_orders)
monthly_profit <- sales_in_usd(sales) - total_costs(hired_workers, product_orders, sales)
return(monthly_profit)
}
# Evaluation Function
F2 <- function(solution){
hired_workers  <- matrix(matrix_transform(solution        = solution,
start           = 1,
elements        = 12,
dimension_start = 1,
bits            = bits_workers), nrow = 3, ncol = 4)
product_orders <- matrix(matrix_transform(solution        = solution,
start           = 12 * bits_workers + 1,
elements        = 16,
dimension_start = 13,
bits            = bits_orders), nrow = 4, ncol = 4)
monthly_effort <- total_number_of_workers(hired_workers) + total_number_of_orders(product_orders)
return(-monthly_effort) # needs to be negative because tabuSearch only maximizes
}
# Evaluation Function Multi Objective
multi_eval <- function(solution){
hired_workers  <- matrix(matrix_transform(solution        = solution,
start           = 1,
elements        = 12,
dimension_start = 1,
bits            = bits_workers), nrow = 3, ncol = 4)
product_orders <- matrix(matrix_transform(solution        = solution,
start           = 12 * bits_workers + 1,
elements        = 16,
dimension_start = 13,
bits            = bits_orders), nrow = 4, ncol = 4)
monthly_effort <- total_number_of_workers(hired_workers) + total_number_of_orders(product_orders)
sales          <- calculate_sales(actual_sales, hired_workers, product_orders)
monthly_profit <- sales_in_usd(sales) - total_costs(hired_workers, product_orders, sales)
return(monthly_profit-monthly_effort)
}
# Function to build Initial Config
initial_config_build <- function(config, n_bits, dimensions){
initial_length <- length(config)
while(length(config) - initial_length < dimensions * n_bits){
config <- c(config, rep(0, n_bits), rep(1, n_bits))
}
return(config)
}
tabu_search <- function(initial_config, func = NULL){
if(func == "Eval"){
solution <- tabuSearch(size, iters = N, objFunc = eval      , config = initial_config, verbose = TRUE)
}else if(func == "F2"){
solution <- tabuSearch(size, iters = N, objFunc = F2        , config = initial_config, verbose = TRUE)
}else if(func == "Both"){
solution <- tabuSearch(size, iters = N, objFunc = multi_eval, config = initial_config, verbose = TRUE)
}
b  <- which.max(solution$eUtilityKeep) # best index
bs <- solution$configKeep[b,]
hired_workers  <- matrix(matrix_transform(solution        = bs,
start           = 1,
elements        = 12,
dimension_start = 1,
bits            = bits_workers), nrow = 3, ncol = 4)
product_orders <- matrix(matrix_transform(solution        = bs,
start           = 12 * bits_workers + 1,
elements        = 16,
dimension_start = 13,
bits            = bits_orders), nrow = 4, ncol = 4)
monthly_effort <- total_number_of_workers(hired_workers) + total_number_of_orders(product_orders)
sales          <- calculate_sales(actual_sales, hired_workers, product_orders)
monthly_profit <- sales_in_usd(sales) - total_costs(hired_workers, product_orders, sales)
cat("Best Solution with ", func,": \nHired Workers \n")
print(hired_workers)
cat("\nProduct Orders \n")
print(product_orders)
cat("\nSales \n")
print(sales)
cat("\nMonthly Profit:", monthly_profit,"\n")
cat("\nMonthly Effort:", monthly_effort,"\n")
cat("\nSolution in Binary Space\n")
print(bs)
}
actual_sales <- data.frame(
WSdep1 = c(54480 , 42221 , 36267 , 35283 ),
WSdep2 = c(159460, 156945, 146388, 132156),
WSdep3 = c(63584 , 62888 , 62768 , 60279 ),
WSdep4 = c(127009, 124560, 123346, 117375)
)
# global variables (can be used inside the functions):
D            <- 28 # dimension
Low          <- rep(0, 28) # Lower
Up           <- calculate_uppers(actual_sales) # Upper
bits_workers <- ceiling(max(log(Up[1:12] , 2))) # Bits for Hired Workers
bits_orders  <- ceiling(max(log(Up[13:28], 2))) # Bits for Product Orders
N            <- 100 # number of iterations
size         <- 12 * bits_workers + 16 * bits_orders # solution size
cat("Tabu Search Sphere D =", D,"( iters =", N,")\n")
# Building Initial configuration
s <- c()
# Building Initial configuration for Hired Workers
s <- initial_config_build(config     = s,
n_bits     = bits_workers,
dimensions = 12)
# Building Initial configuration for Product Orders
s <- initial_config_build(config     = s,
n_bits     = bits_orders,
dimensions = 16)
s
solution = s
start           = 1
elements        = 12
dimension_start = 1
bits            = bits_workers
matrix_final <- c()
for(i in 1:elements){
matrix_final[i]  <- bin2int(solution[start:(start + bits - 1)])
start <- start + bits
}
matrix_final
matrix_final[i]  <-solution[start:(start + bits - 1)]
matrix_final <- c()
for(i in 1:elements){
matrix_final[i]  <-solution[start:(start + bits - 1)]
start <- start + bits
}
solution
start           = 1
matrix_final <- c()
for(i in 1:elements){
matrix_final[i]  <-solution[start:(start + bits - 1)]
start <- start + bits
}
solution        = solution
start           = 1
elements        = 12
dimension_start = 1
bits            = bits_workers
matrix_final <- c()
for(i in 1:elements){
matrix_final[i]  <-solution[start:(start + bits - 1)]
start <- start + bits
}
matrix_final
solution[start:(start + bits - 1)]
matrix_final[i]  <- bin2int(solution[start:(start + bits - 1)])
matrix_final
matrix_final[i]  <- bin2int(solution[start:(start + bits - 1)])
start <- start + bits
for(i in 1:elements){
matrix_final[i]  <- bin2int(solution[start:(start + bits - 1)])
start <- start + bits
}
matrix_final
hired_workers  <- matrix(matrix_transform(solution        = solution,
start           = 1,
elements        = 12,
dimension_start = 1,
bits            = bits_workers), nrow = 3, ncol = 4)
hired_workers
bin2int(111111)
product_orders <- matrix(matrix_transform(solution        = solution,
start           = 12 * bits_workers + 1,
elements        = 16,
dimension_start = 13,
bits            = bits_orders), nrow = 4, ncol = 4)
product_orders
sales          <- calculate_sales(actual_sales, hired_workers, product_orders)
monthly_profit <- sales_in_usd(sales) - total_costs(hired_workers, product_orders, sales)
monthly_profit
# you need to install this package:
library(genalg)
# definition of the famous rastrigin function
# x is a vector with D real values.
rastrigin=function(x=c()) { return (sum(x^2-10*cos(2*pi*x)+10))}
# rbga accepts the possibility to execute a monitor function, defined by the user.
# obj$population contains the population of the rbga alfgorithm
# the monitor function is executed in every iteration (generation) of the algorithm.
# in this case, monitor will plot the search space for D=2,
# where the points color will get darker as the generations increase:
monitor=function(obj) {
xlim = c(-LIM,LIM) # x-axis limits
ylim = c(-LIM,LIM) # y-axis limits
COL=paste("gray",80-ITER*4,sep="") # set the points color depending on ITER
for(i in 1:nrow(obj$population))
cat(obj$population[i,]," fit:",obj$evaluations[i],"\n") # show in console all individual values and fitness
PMIN=which.min(obj$evaluations) # show which point provides the best (lowest) value
cat("PMIN:",PMIN,"\n")
plot(obj$population, xlim=xlim, ylim=ylim, xlab="x", ylab="y",pch=19,cex=0.5,col=COL) # plot all points
#plot(obj$population, xlim=xlim, ylim=ylim, xlab="x", ylab="y",pch=19,cex=sizepop(obj$evaluations));
text(obj$population[PMIN,1],obj$population[PMIN,2],"min") # put the label "min" near the best point
cat("-- generation:",ITER,"(press enter)\n");readLines(n=1) # wait for user to press enter
ITER<<-ITER+1 # global variable ITER increase (outside this function, ITER is valid)
}
LIM=5.12 # used for lower and upper bounds, global variable
# first experiment, popSize=20:
ITER<<-1 # global variable assignment (because monitor only receives obj as input)
rga=rbga(c(-LIM,-LIM),c(LIM,LIM),popSize=20,mutationChance=0.33,elitism=1,evalFunc=rastrigin,monitorFunc=monitor,iter=20)
source("~/Universidade/4º Ano/TIAPOSE/Walmart-TIAPOSE/Code/Otimização/MultiObjective.R")
setwd("~/Universidade/4º Ano/TIAPOSE/Walmart-TIAPOSE/Code/Otimização")
source("~/Universidade/4º Ano/TIAPOSE/Walmart-TIAPOSE/Code/Otimização/MultiObjective.R")
install.packages("mco")
source("~/Universidade/4º Ano/TIAPOSE/Walmart-TIAPOSE/Code/Otimização/MultiObjective.R")
source("functions_Otimization.R")
library(mco)
# definir as vendas da semana
actual_sales <- data.frame(
WSdep1 = c(54480,42221,36267,35283),
WSdep2 = c(159460,156945,146388,132156),
WSdep3 = c(63584,62888,62768,60279),
WSdep4 = c(127009,124560,123346,117375)
)
## Define the eval function
eval <- function(s){
s <- round(s)
hired_workers = matrix(s[1:12], nrow=3, ncol=4)
product_orders = matrix(s[13:28], nrow=4, ncol=4)
sales = calculate_sales(actual_sales, hired_workers, product_orders)
monthly_profit = sales_in_usd(sales) - total_costs(hired_workers, product_orders, sales)
return(-monthly_profit)
}
F2 <- function(s){
s <- round(s)
hired_workers = matrix(s[1:12], nrow=3, ncol=4)
product_orders = matrix(s[13:28], nrow=4, ncol=4)
monthly_effort  = total_number_of_workers(hired_workers) + total_number_of_orders(product_orders)
return(monthly_effort)
}
##################### PARAMETERS #################
# dimension
D <- 28
lower <- rep(0, D)  # limites inferiores
upper <- calculate_uppers(actual_sales)  # limites superiores
# define a função de objetivo como uma combinação de eval e F2
objective_function <- function(x) {
x <- round(x)
c(eval(x), F2(x))
}
# execute a otimização multiobjetivo
G <- nsga2(fn = objective_function, idim = D, odim = 2,
lower.bounds = lower, upper.bounds = upper,
popsize = 200, generations = 1:1000)
upper
# execute a otimização multiobjetivo
G <- nsga2(fn = objective_function, idim = D, odim = 2,
lower.bounds = lower, upper.bounds = upper,
popsize = 200, generations = 1:1000)
# define a função de objetivo como uma combinação de eval e F2
objective_function <- function(x) {
x <- round(x)
return(c(eval(x), F2(x)))
}
# execute a otimização multiobjetivo
G <- nsga2(fn = objective_function, idim = D, odim = 2,
lower.bounds = lower, upper.bounds = upper,
popsize = 200, generations = 1:1000)
G
# mostrar os melhores indivíduos
I <- which(G[[100]]$pareto.optimal)
for (i in I) {
x <- round(G[[100]]$par[i,], digits = 0)
cat("Hired workers and product orders:", x, "\n")
cat("Monthly profit:", eval(x), "\n")
cat("Monthly effort:", F2(x), "\n\n")
}
# create PDF com a evolução da fronteira de Pareto
pdf(file = "nsga-eval-F2.pdf", paper = "special", height = 5, width = 5)
par(mar = c(4.0, 4.0, 0.1, 0.1))
I <- 1:100
for (i in I) {
P <- G[[i]]$value  # objetivos f1 e f2
# color from light gray (75) to dark (1):
COL <- paste("gray", round(76 - i * 0.75), sep = "")
if (i == 1) plot(P, xlim = c(0, max(P[,1]) * 1.1), ylim = c(0, max(P[,2]) * 1.1),
xlab = "f1", ylab = "f2", cex = 0.5, col = COL, main = "Pareto Front Evolution")
Pareto <- P[G[[i]]$pareto.optimal, ]
# sort Pareto according to x axis:
points(P, type = "p", pch = 1, cex = 0.5, col = COL)
if (is.matrix(Pareto)) {  # if Pareto has more than 1 point
I <- sort.int(Pareto[,1], index.return = TRUE)
Pareto <- Pareto[I$ix, ]
lines(Pareto, type = "l", cex = 0.5, col = COL)
}
}
dev.off()
?plot
source("~/Universidade/4º Ano/TIAPOSE/Walmart-TIAPOSE/Code/Otimização/MultiObjective.R")
source("functions_Otimization.R")
library(mco)
# definir as vendas da semana
actual_sales <- data.frame(
WSdep1 = c(54480,42221,36267,35283),
WSdep2 = c(159460,156945,146388,132156),
WSdep3 = c(63584,62888,62768,60279),
WSdep4 = c(127009,124560,123346,117375)
)
## Define the eval function
eval <- function(s){
s <- round(s)
hired_workers = matrix(s[1:12], nrow=3, ncol=4)
product_orders = matrix(s[13:28], nrow=4, ncol=4)
sales = calculate_sales(actual_sales, hired_workers, product_orders)
monthly_profit = sales_in_usd(sales) - total_costs(hired_workers, product_orders, sales)
pareto_curve <<- c(pareto_curve, -monthly_profit)
return(-monthly_profit)
}
F2 <- function(s){
s <- round(s)
hired_workers = matrix(s[1:12], nrow=3, ncol=4)
product_orders = matrix(s[13:28], nrow=4, ncol=4)
monthly_effort  = total_number_of_workers(hired_workers) + total_number_of_orders(product_orders)
return(monthly_effort)
}
##################### PARAMETERS #################
# dimension
D <- 28
lower <- rep(0, D)  # limites inferiores
upper <- calculate_uppers(actual_sales)  # limites superiores
upper
pareto_curve <- c()
# define a função de objetivo como uma combinação de eval e F2
objective_function <- function(x) {
x <- round(x)
c(eval(x), F2(x))
}
# execute a otimização multiobjetivo
G <- nsga2(fn = objective_function, idim = D, odim = 2,
lower.bounds = lower, upper.bounds = upper,
popsize = 200, generations = 1:1000)
# mostrar os melhores indivíduos
I <- which(G[[100]]$pareto.optimal)
I
for (i in I) {
x <- round(G[[100]]$par[i,], digits = 0)
cat("Hired workers and product orders:", x, "\n")
cat("Monthly profit:", eval(x), "\n")
cat("Monthly effort:", F2(x), "\n\n")
}
# create PDF com a evolução da fronteira de Pareto
pdf(file = "nsga-eval-F2.pdf", paper = "special", height = 5, width = 5)
par(mar = c(4.0, 4.0, 0.1, 0.1))
I <- 1:100
for (i in I) {
P <- G[[i]]$value  # objetivos f1 e f2
# color from light gray (75) to dark (1):
COL <- paste("gray", round(76 - i * 0.75), sep = "")
if (i == 1) plot(P, xlim = c(0, max(P[,1]) * 1.1), ylim = c(0, max(P[,2]) * 1.1),
xlab = "f1", ylab = "f2", cex = 0.5, col = COL, main = "Pareto Front Evolution")
Pareto <- P[G[[i]]$pareto.optimal, ]
# sort Pareto according to x axis:
points(P, type = "p", pch = 1, cex = 0.5, col = COL)
if (is.matrix(Pareto)) {  # if Pareto has more than 1 point
I <- sort.int(Pareto[,1], index.return = TRUE)
Pareto <- Pareto[I$ix, ]
lines(Pareto, type = "l", cex = 0.5, col = COL)
}
}
Pareto
for (i in I) {
P <- G[[i]]$value  # objetivos f1 e f2
# color from light gray (75) to dark (1):
COL <- paste("gray", round(76 - i * 0.75), sep = "")
if (i == 1) plot(P, xlim = c(0, max(P[,1]) * 1.1), ylim = c(0, max(P[,2]) * 1.1),
xlab = "f1", ylab = "f2", cex = 0.5, col = COL, main = "Pareto Front Evolution")
Pareto <- P[G[[i]]$pareto.optimal, ]
# sort Pareto according to x axis:
plot(P, type = "p", pch = 1, cex = 0.5, col = COL)
if (is.matrix(Pareto)) {  # if Pareto has more than 1 point
I <- sort.int(Pareto[,1], index.return = TRUE)
Pareto <- Pareto[I$ix, ]
lines(Pareto, type = "l", cex = 0.5, col = COL)
}
}
plot(pareto_curve, type = "p")
Pareto <- P[G[[i]]$pareto.optimal, ]
# create PDF com a evolução da fronteira de Pareto
pdf(file = "nsga-eval-F2.pdf", paper = "special", height = 5, width = 5)
par(mar = c(4.0, 4.0, 0.1, 0.1))
I <- 1:100
for (i in I) {
P <- G[[i]]$value  # objetivos f1 e f2
# color from light gray (75) to dark (1):
COL <- paste("gray", round(76 - i * 0.75), sep = "")
if (i == 1) plot(P, xlim = c(0, max(P[,1]) * 1.1), ylim = c(0, max(P[,2]) * 1.1),
xlab = "f1", ylab = "f2", cex = 0.5, col = COL, main = "Pareto Front Evolution")
Pareto <- P[G[[i]]$pareto.optimal, ]
# sort Pareto according to x axis:
plot(P, type = "p", pch = 1, cex = 0.5, col = COL)
if (is.matrix(Pareto)) {  # if Pareto has more than 1 point
I <- sort.int(Pareto[,1], index.return = TRUE)
Pareto <- Pareto[I$ix, ]
lines(Pareto, type = "l", cex = 0.5, col = COL)
}
}
